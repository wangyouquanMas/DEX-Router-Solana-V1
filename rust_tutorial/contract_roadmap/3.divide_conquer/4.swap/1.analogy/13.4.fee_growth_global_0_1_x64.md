ÁõÆÊ†áÔºö
1. ÁêÜËß£fee_growth_global_0/1_x64 ‰ΩúÁî®

ÂÜÖÂÆπÔºö
1. ‰ΩúÁî®
Ensuring that each position earns its proportional share of the fees taht were accrued while it was within range, which requires some accounting within the pool. 

1.1. Fees

[TODO:]Fee(ùõæ), representing the fee paid by swappers in units of hundredths of a basis point(0.0001%).

It also tracks the current protocol fee, ùúô (which is initialized to zeroÔºâ. 
This number gives you the fraction of the fees paid by swappers that currently goes to the protocol rather than to liquidity providers.  ùúô only has a limited set of permitted values: 0, 1/4, 1/5, 1/6, 1/7, 1/8, 1/9, or 1/10.

1.2 feeGrowthGlobal0/1
The global state also tracks two numbers: feeGrowthGlobal0 and feeGrowthGlobal1. 
[TODO:]These represent the total amount of fees that have been earned per unit of virtual liquidity(L), over the entire history of the contract. 
You can think of them as the total amount of fees that would have been earned by 1 unit of unbounded liquidity that was deposited when the contract was first initialized.
They are stored as fixed-point unsigned 128*128numbers. 
[TODO: ]Not that in Uniswap V3, fees are collected in the tokens themselves rather than in liquidity.


1.3 protocolFees0/1 ùúô 
Finally, the global state tracks the total accumulated uncollected protocol fee in each token, protocolFees0 and protocolFees1. This is an unsigned unit128. The accumulated protocol fees can be collected by UNI governance, by calling the collectProtocol funciton.


1.4 ËÆ°ÁÆóÂÖ¨Âºè„Äêswapping within a single TIck„Äë
For small enough swaps, that do not move the price past a tick, the contracts act like an x*y = k pool. 
Suppose r is the fee. i.e.,0.003, and y_in as the amount of token1 sent in.
First,feeGrowthGlobal1 and protocolFees1 are incremented:

Œîùëìùëî,1 = ùë¶ùëñùëõ ¬∑ ùõæ ¬∑ (1 ‚àí ùúô)
Œîùëìùëù,1 = ùë¶ùëñùëõ ¬∑ ùõæ ¬∑ ùúô 

Œîùë¶ is the increase in ùë¶ (after the fee is taken out).
Œîùë¶ = ùë¶ùëñùëõ ¬∑ (1 ‚àíùõæ)


1.5 ÂÆûÈ™å
1ÔºâWhen is it initialized?
PoolState::initialize in programs/amm/src/states/pool.rs zeroes fee_growth_global_0_x64 when the pool account is created, so every new pool starts with 0.

location: programs/amm/src/states/pool.rs
function:  initialize()


2) When fee_growth_global_0/1_x64 is updated ?
During swaps, programs/amm/src/instructions/swap.rs assigns pool_state.fee_growth_global_0_x64 = state.fee_growth_global_x64 (for the zero-for-one branch) after the core swap math runs; this is the live update path on-chain.


if state.liquidity > 0 {
    //TODO: ? delta 
    let fee_growth_global_x64_delta = U128::from(step.fee_amount)
                .mul_div_floor(U128::from(fixed_point_64::Q64), U128::from(state.liquidity))
                .unwrap()
                .as_u128();

    state.fee_growth_global_x64 = state
                .fee_growth_global_x64
                .checked_add(fee_growth_global_x64_delta)
                .unwrap();
    state.fee_amount = state.fee_amount.checked_add(step.fee_amount).unwrap();
  }

location: programs/amm/src/instructions/swap.rs
function: swap_internal 
   if zero_for_one {
        pool_state.fee_growth_global_0_x64 = state.fee_growth_global_x64;
        ...
   }else{
        pool_state.fee_growth_global_1_x64 = state.fee_growth_global_x64;
        ...
   }

2.1) fee_amount Âê´‰πâ

Initialized value : 
let mut state = SwapState{
    fee_amount:0,
}

compute_swap_step:
  swap_step.fee_amount =
        if is_base_input && swap_step.sqrt_price_next_x64 != sqrt_price_target_x64 {
            // we didn't reach the target, so take the remainder of the maximum input as fee
            // swap dust is granted as fee
            u64::from(amount_remaining)
                .checked_sub(swap_step.amount_in)
                .unwrap()
        } else {
            // take pip percentage as fee
            swap_step
                .amount_in
                .mul_div_ceil(
                    fee_rate.into(),
                    (FEE_RATE_DENOMINATOR_VALUE - fee_rate).into(),
                )
                .unwrap()
        };

ÂëΩ‰ª§Ôºö./target/release/client swap KAuLYYFUG38kjJHRFTQ9werR6sRtLEK2PHJzXMmb56L 5Kar97KcLTHFP7iMMbRgB74zXHVL43yEmURwD3Z6RvdT  --base-in 100

Êó•ÂøóÔºö 
1amount_remaining: 100
1swap_step.amount_in: 99
1fee_amount: 1

TODO: Meaning of fee_amount ?
Case 1: Target price still not reached
    swap_step.sqrt_price_next_x64 != sqrt_price_target_x64
    Because the price didn‚Äôt make it all the way to the tick target, the code treats the unused remainder as fee:
    fee_amount = amount_remaining - amount_in
            = 1_000 - 997
            = 3
    All 1,000 tokens leave your wallet: 997 are swapped, 3 become fee ‚Äúdust‚Äù.

Case 2: Target price reached
    swap_step.sqrt_price_next_x64 == sqrt_price_target_x64
    Here the tick target is hit, so the fee is taken via the configured percentage:
   
    fee_amount = amount_in * fee_rate / (denominator - fee_rate)
           ‚âà 997 * 3000 / 997000
           ‚âà 3.00 (ceil‚Äôd to 3)
    Again 1,000 tokens leave your wallet: 997 are swapped, ~3 go to fees.
In both cases amount_in + fee_amount = amount_remaining, but one computes the fee as leftover dust, the other as the explicit percentage.



1Ôºâ steate.liquidity: 11619165270

let fee_growth_global_x64_delta = U128::from(step.fee_amount)
                .mul_div_floor(U128::from(fixed_point_64::Q64), U128::from(state.liquidity))
                .unwrap()
                .as_u128();

2Ôºâfee_growth_global_x64_delta: 1587613537

//TODO: fee_growth_global_x64_delta ÂÆö‰πâ
That delta transforms the fees collected in this step into ‚Äúper unit of liquidity‚Äù terms (using Q64 fixed-point scaling) and accumulates it in state.fee_growth_global_x64. Later, when positions claim fees, they read the change in this accumulator over the period they were active, multiply by their liquidity, and get the fees owed.

>>> 1*2**64 / 11619165270
1587613537.2080436

3Ôºâbefore state.fee_growth_global_x64: 4757129965730792
 state.fee_growth_global_x64 = state
                .fee_growth_global_x64
                .checked_add(fee_growth_global_x64_delta)
                .unwrap();
after state.fee_growth_global_x64: 4757131553344329
>>> 4757129965730792 + 1587613537
4757131553344329

//TODO: fee_growth_global_x64Âê´‰πâÔºü
`fee_growth_global_x64` is the running accumulator of fees per unit of liquidity for the pool. During each swap step, the code figures out how much new fee-per-liquidity needs to be added; that increment is `fee_growth_global_x64_delta`. It‚Äôs calculated from the step‚Äôs collected fee, scaled to Q64 fixed point, and divided by the current liquidity. The global accumulator is then updated by adding the delta:
```376:385:programs/amm/src/instructions/swap.rs
let fee_growth_global_x64_delta = U128::from(step.fee_amount)
    .mul_div_floor(U128::from(fixed_point_64::Q64), U128::from(state.liquidity))
    .unwrap()
    .as_u128();
// ... existing code ...
state.fee_growth_global_x64 = state
    .fee_growth_global_x64
    .checked_add(fee_growth_global_x64_delta)
    .unwrap();
```
So the delta is just the incremental increase, while `fee_growth_global_x64` is the accumulated total that liquidity providers reference to settle fees.

TODO: so let's say swapA causes each liquidity unit 1fee earned, swapB cause 2fee earned.  then global accumulator add them together, now 3fee each liquidity net ?

Right: ignoring any rounding, the first swap contributes 1 fee-per-liquidity unit, the second adds 2, and the accumulator ends at 3. When a position later claims, it integrates the change in `fee_growth_global_x64` over the period it was active, multiplies by its liquidity, and that yields the total fees owed.


4Ôºâafter state.fee_amount: 1
state.fee_amount = state.fee_amount.checked_add(step.fee_amount).unwrap();
state.fee_amountÔºö0

5Ôºâpool_state.fee_growth_global_1_x64 Áî±state.fee_growth_global_x64ËµãÂÄº
log: Program log: 3 after state.fee_growth_global_x64: 4757133140957866
log: Program log: 3 after state.fee_amount: 1
log: Program log: 4 pool_state.fee_growth_global_1_x64: 4757133140957866

fee_growth_global_1_x64Ôºö4757133140957866
let fee_growth_global_1_x64 = pool_state.fee_growth_global_1_x64;
msg!("4 pool_state.fee_growth_global_1_x64: {}",fee_growth_global_1_x64);       



