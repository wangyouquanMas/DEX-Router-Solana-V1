目标：
1. 理解fee_growth_inside_0/1_last_x64的作用

内容：
1. 作用

/// The token_0 fee growth of the aggregate position as of the last action on the individual position
    pub fee_growth_inside_0_last_x64: u128,

/// The token_1 fee growth of the aggregate position as of the last action on the 
    individual position
    pub fee_growth_inside_1_last_x64: u128,


1.1 fee_growth_inside 是LP的流动性获取的费用


1.2 Definition 
`fee_growth_inside_0_last_x64` stores the last recorded value of the pool’s token‑0 fee growth (per unit of liquidity) that falls inside this position’s tick range, expressed in Q64.64 fixed‑point units. When the position is touched (opening, adding/removing liquidity, collecting fees), the program snapshots the current global fee growth into this field; later, it computes newly earned fees by comparing the latest pool growth against this stored value.


It isn’t the fee amount itself. fee_growth_inside_{0,1}_last_x64 stores the per-liquidity fee-growth accumulator inside the position’s tick range at the moment the position was last touched. When you later adjust liquidity or collect fees, the program subtracts this stored value from the current “inside” fee-growth accumulator, multiplies the delta by your liquidity, and that difference becomes the newly earned fees. So it tracks the accounting checkpoint for fees earned within the range, not the actual fee balance.


1.3 When is it updated?

1) on creation in open_position
location: programs/amm/src/instructions/open_position.rs
code:   personal_position.fee_growth_inside_0_last_x64 =
            protocol_position.fee_growth_inside_0_last_x64;
        personal_position.fee_growth_inside_1_last_x64 =
            protocol_position.fee_growth_inside_1_last_x64;

Experiment:


2) After liquidity changes


1.4 what's the purpose of it ?
It's a snapshot?. 
fee_growth_inside_*_last_x64 is essentially a per-position snapshot of the fee-growth accumulator taken at the last time you touched the position. Each time you collect or modify liquidity, the program compares the current accumulator with that snapshot to figure out how much new fee growth occurred for your liquidity since the previous checkpoint.

```29:37:programs/amm/src/states/personal_position.rs
    pub liquidity: u128,
    pub fee_growth_inside_0_last_x64: u128,
    pub fee_growth_inside_1_last_x64: u128,
    pub token_fees_owed_0: u64,
    pub token_fees_owed_1: u64,
```

Picture a pool where the “inside” fee-growth accumulator for token 0 (`fee_growth_inside_0_x64`) increases whenever trades happen within your tick range.  

- You mint a position with 1 000 liquidity while the accumulator is 100. Your `fee_growth_inside_0_last_x64` is set to 100. No fees are owed yet.  
- Over time, swaps push the accumulator to 160. When you next touch the position (collect or adjust liquidity), the program computes the delta: 160 − 100 = 60. Multiply by your liquidity (1 000) and scale back from Q64.64, and you get the newly accrued fees. Those fees are credited to `token_fees_owed_0`.  
- The checkpoint `fee_growth_inside_0_last_x64` is then rewritten to 160 so the next delta only captures additional growth.

Without this checkpoint field, the program couldn’t know which part of the global fee growth occurred before you added liquidity (and therefore shouldn’t belong to you) versus the portion you actually earned.



1.5 The relationship between fee_growth_global, fee_growth_inside and fee_growth_inside_last?
They are related but not interchangeable:

- **`fee_growth_global_*_x64`** sits on the pool and accumulates every unit of fee growth ever produced in the pool, across all ticks and all LPs. It’s the raw total.
- **`fee_growth_inside_*_x64`** is derived from the global value but stripped of the “outside your range” portions: `inside = global − below(lower) − above(upper)`. That makes it specific to a tick band.
- **`fee_growth_inside_*_last_x64`** on the position is your personal checkpoint of that inside accumulator taken the last time you touched the position.

So yes, “inside” is still built from the global accumulator, but it’s filtered to just the range you cover. The snapshot stored in your position lets the program award only the incremental inside growth since you last interacted.