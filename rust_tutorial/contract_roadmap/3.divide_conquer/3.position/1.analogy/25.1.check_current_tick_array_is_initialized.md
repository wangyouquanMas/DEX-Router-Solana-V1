目标：
1. 掌握tickarray_bitmap_extension再判断tickarray是否initialized中的作用


实践：
1. 作用分析

1.1 source code 


/// Given a tick, calculate whether the tickarray it belongs to has been initialized.
/// Note: The caller of the function should ensure that tick_current is within the range represented by bit_map.
/// Currently, this function is only called when `bit_map = pool.tick_array_bitmap`.
pub fn check_current_tick_array_is_initialized(
    bit_map: U1024,
    tick_current: i32,
    tick_spacing: u16,
) -> Result<(bool, i32)> {
    println!("tick_current: {:?}", tick_current);
    println!("tick_spacing: {:?}", tick_spacing);

    if TickState::check_is_out_of_boundary(tick_current) {
        return err!(ErrorCode::InvalidTickIndex);
    }
    let multiplier = i32::from(tick_spacing) * TICK_ARRAY_SIZE;
    let mut compressed = tick_current / multiplier + 512;
    println!("compressed: {:?}", compressed);
    if tick_current < 0 && tick_current % multiplier != 0 {
        // round towards negative infinity
        compressed -= 1;
    }
    println!("compressed: {:?}", compressed);
    let bit_pos = compressed.abs();
    println!("bit_pos: {:?}", bit_pos);
    // set current bit
    let mask = U1024::one() << bit_pos.try_into().unwrap();
    let masked = bit_map & mask;
    // check the current bit whether initialized
    let initialized = masked != U1024::default();
    if initialized {
        println!("true");
        return Ok((true, (compressed - 512) * multiplier));
    }
    println!("false");
    // the current bit is not initialized
    return Ok((false, (compressed - 512) * multiplier));
}


1.2 adding logs 
tick_current: -1
tick_spacing: 60

let multiplier = i32::from(tick_spacing) * TICK_ARRAY_SIZE;
let mut compressed = tick_current / multiplier + 512;
println!("compressed: {:?}", compressed);  //compressed: 512

if tick_current < 0 && tick_current % multiplier != 0 {
        // round towards negative infinity
        compressed -= 1;
} // 511

let bit_pos = compressed.abs();
println!("bit_pos: {:?}", bit_pos); //bit_pos: 511

let mask = U1024::one() << bit_pos.try_into().unwrap();
let masked = bit_map & mask;

 let initialized = masked != U1024::default();
if initialized {
        println!("true");
        return Ok((true, (compressed - 512) * multiplier));
}

1.3. Problems?
