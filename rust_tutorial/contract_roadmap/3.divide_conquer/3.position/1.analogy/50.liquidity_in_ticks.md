目标：
1. 掌握在一个 price range中，left和right border对应的边界 tick中的流动性是什么？

内容：
1. 边界

实验：
首次添加流动性： ./target/release/client open-position 0.8 1.2 --is-base-0 100

    //ticklower: 
    // tick[22]: tick=-2280, liquidity_gross=0.0000000006298762114101061 (raw: 11619165270), 
    // liquidity_net=0.0000000006298762114101061 (raw: 11619165270)

    //tickupper:
    //tick[30]: tick=1800, liquidity_gross=0.0000000006298762114101061 (raw: 11619165270), 
    // liquidity_net=-0.0000000006298762114101061 (raw: -11619165270)

    poolstate: liquidity: 116191652 ; sqrt_price_x64: 18446744073709551616 ; tick_current: 0
    liquidity: 116191652 ; sqrt_price_x64: 18446585789997115657  ; tick_current: -1

问题： TODO:
1） 为什么tick=-2280 liquidity_net 是正的 [进入]；  tick=1800 liquidity_net 是负的 【离开】

所以，如果从右到左， 需要离开, 减去流动性； 【tick_lower_state  all ticks < 0】  ？ 
所以，如果从左到右， 需要进入, 加上流动性； 【tick_upper_state  all ticks > 0】  ？



pool_state.tick_current :  tick current: tick: -86 [tick_index] 
        step.tick_next = next_initialized_tick.tick;
        step.initialized = next_initialized_tick.is_initialized();
        //step.tick_next: -2280
        msg!("step.tick_next: {}", step.tick_next);
        //step.initialized: true
        msg!("step.initialized: {}", step.initialized);

当tickcurrent 为-2280
liquidity: 164564904  


交易： swap 跨越了区间tick = -2280, 然后tickstate 再-2280处已经初始化了，然后其对应的 liquidity 116191652 被从pool state liquidity中删除掉了。然后pool liquidity更新为：96787912。 也就是说，再-2281 -> 下一个initialized的tick 【在-3600的tickarray中】， 在它们之间【-3600,-2281】的流动性为96787912，这一点可以通过查看initialized的tickstate[ tick在-3600处]的liquidity字段值。

       //> Program log: updated pool_state.liquidity: 212979564
        // > Program log: updated pool_state.liquidity: 96787912
        差值： 
        >>> 212979564 - 116191652
            96787912
            96787912 = 48373252 + 48414660  【-6960, -2280】 之间的流动性是累积和【价格范围重复了】

        持续兑换 liquidity: 48414660 = 96787912 - 48373252  
                tick_current: -7581

tick[4]: tick=-6960, liquidity_gross=0.0000000000026223192454294386 (raw: 48373252), liquidity_net=0.0000000000026223192454294386 (raw: 48373252)

tick[39]: tick=-12060, liquidity_gross=0.0000000000026245639776073526 (raw: 48414660), liquidity_net=0.0000000000026245639776073526 (raw: 48414660)


从左向右： 
池初始状态：
liquidity: 11619165270
sqrt_price_x64: 18446744073709551616
tick_current: 0

开仓： 0.8-1.2  1000000000
open_position_with_token22_nft_instr liquidity: 11619165270
tick_array_lower: AUkVLEit7vE5Gg11uS8mYMEQkVhoWfszcmxHxXEHo7Fu
tick[22]: tick=-2280, liquidity_gross=0.0000000006298762114101061 (raw: 11619165270), liquidity_net=0.0000000006298762114101061 (raw: 11619165270)

tick_array_upper: ETGUUHvn8xEs8cuZbvk19xa6qPrmficGHzkSiqFeYLNt
tick[30]: tick=1800, liquidity_gross=0.0000000006298762114101061 (raw: 11619165270), liquidity_net=-0.0000000006298762114101061 (raw: -11619165270)

swap到达边界后，流动性耗光。池子当前状态：
liquidity: 11619165270
sqrt_price_x64: 20183860982046954580 // 1.1972064489525853
tick_current: 1799

重新添加流动性： 1.3-1.5  16377606417
tick_array_lower: ETGUUHvn8xEs8cuZbvk19xa6qPrmficGHzkSiqFeYLNt
tick[30]: tick=1800, liquidity_gross=0.0000000006298762114101061 (raw: 11619165270), liquidity_net=-0.0000000006298762114101061 (raw: -11619165270)
tick[43]: tick=2580, liquidity_gross=0.0000000008878318228711969 (raw: 16377606417), liquidity_net=0.0000000008878318228711969 (raw: 16377606417)

tick_array_upper: 7J7eLmvJ9ogiqZA2MWaC3pedGaW2GWQTsMnkfCSjgruc
tick[7]: tick=4020, liquidity_gross=0.0000000008878318228711969 (raw: 16377606417), liquidity_net=-0.0000000008878318228711969 (raw: -16377606417)

继续执行swap [amountin: 10000], 当前池子状态：
liquidity: 16377606417
sqrt_price_x64: 20986553591535978886 //1.2943234045175869
tick_current: 2580

//TODO: 1. 如果当前[tick1,tick2] [tick3,tick4] 是间隔的。[tick2,tick3]之间没有流动性， 
这时候，价格需要越过tick2，进入[tick2,tick3]之间，会做什么处理 ? 是直接将价格跳到[tick3,tick4]区间吗？
如果不处理，那么价格进入了一个没有流动性的区间，会影响swap吗？ 

目前，猜测是直接跳到下一个有流动性的价格区间。 通过实验，验证了该结论。

liquidity: 36442771316
sqrt_price_x64: 21821146762755348346 //1.399315663489375
tick_current: 3360

tick_array_lower: 289j3RKSAnDadt7HceTvXEoNR35BNQjPSemT7VW7Ymbe
tick[56]: tick=3360, liquidity_gross=0.0000000019755665916099813 (raw: 36442771316), liquidity_net=0.0000000019755665916099813 (raw: 36442771316)

tick_array_upper: Dj1X8JSZXWq384mGwMxPMeQbfX3114X79wLTPJxnnPPa


//TODO: 2. 如果是重复的区间，那么从右到左，就应该加上next tick的liquidity net作为total liquidity. 
可以画图理解。




TODO: 找到代码位置
open_position_with_token22_nft
-> open_position
-> add_liquidity
-> modify_position
-> update_position
-> update  [programs/amm/src/states/tick_array.rs]


核心代码实现:
1. liquidity net赋值
self.liquidity_net = if upper {
            //> Program log: upper liquidity_delta: 11619165270
            // > Program log: upper liquidity_net: 0
            msg!("upper liquidity_delta: {}", liquidity_delta);
            let before_liquidity_net = self.liquidity_net;
            msg!("upper liquidity_net: {}", before_liquidity_net);
            self.liquidity_net.checked_sub(liquidity_delta)
        } else {
            //> Program log: lower liquidity_delta: 11619165270
            // > Program log: lower liquidity_net: 0
            msg!("lower liquidity_delta: {}", liquidity_delta);
            let before_liquidity_net = self.liquidity_net;
            msg!("lower liquidity_net: {}", before_liquidity_net);
            self.liquidity_net.checked_add(liquidity_delta)
        }


2. 
// update the ticks if liquidity delta is non-zero
if liquidity_delta != 0 {
        // Update tick state and find if tick is flipped
        flipped_lower = tick_lower_state.update(
            pool_state.tick_current,
            liquidity_delta,
            pool_state.fee_growth_global_0_x64,
            pool_state.fee_growth_global_1_x64,
            false,
            &updated_reward_infos,
        )?;
        msg!("flipped_lower: {}", flipped_lower);
        flipped_upper = tick_upper_state.update(
            pool_state.tick_current,
            liquidity_delta,
            pool_state.fee_growth_global_0_x64,
            pool_state.fee_growth_global_1_x64,
            true,
            &updated_reward_infos,
        )?;


