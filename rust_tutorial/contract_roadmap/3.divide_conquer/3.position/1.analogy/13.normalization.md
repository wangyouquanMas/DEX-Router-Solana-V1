目标：
1. 理解什么是normalization
2. 理解normalization在get a fractional value中的作用？



目标：
1. 什么是normalization 


2. 理解其作用?











# Example of Normalization in the Log₂ Algorithm

Let me show you how the normalization process works with specific examples:

## The Normalization Code

```rust
let mut r = if msb >= 64 {
    sqrt_price_x64 >> (msb - 63)
} else {
    sqrt_price_x64 << (63 - msb)
};
```

This code normalizes the input value (`sqrt_price_x64`) so that it falls within the range [1,2) in Q64.64 fixed-point format.

## Example 1: Large Value Normalization

Let's say we have a value that's larger than 2:

### Input:
- `sqrt_price_x64 = 2^70` (which is 2^6 = 64 in actual value after accounting for x64 format)
- `msb = 70` (the highest bit is at position 70)

### Normalization:
Since `msb >= 64` is true (70 >= 64):
```
r = sqrt_price_x64 >> (msb - 63)
r = 2^70 >> (70 - 63)
r = 2^70 >> 7
r = 2^(70-7) = 2^63
```

In Q64.64 format:
- 2^63 represents the value 0.5 * 2^1 = 1.0
- This is exactly what we want: the value is now normalized to 1.0, which is in the range [1,2)

## Example 2: Medium Value Normalization

Let's try a value that's already between 1 and 2:

### Input:
- `sqrt_price_x64 = 2^64 * 1.5` (which is 1.5 in actual value)
- `msb = 64` (the highest bit is at position 64)

### Normalization:
Since `msb >= 64` is true (64 >= 64):
```
r = sqrt_price_x64 >> (msb - 63)
r = (2^64 * 1.5) >> (64 - 63)
r = (2^64 * 1.5) >> 1
r = 2^64 * 1.5 / 2 = 2^63 * 1.5
```

In Q64.64 format:
- 2^63 * 1.5 represents the value 0.5 * 2^1 * 1.5 = 1.0 * 1.5 = 1.5
- The value remains 1.5, which is already in the range [1,2)

## Example 3: Small Value Normalization

Now let's try a value that's smaller than 1:

### Input:
- `sqrt_price_x64 = 2^60` (which is 2^(60-64) = 2^-4 = 0.0625 in actual value)
- `msb = 60` (the highest bit is at position 60)

### Normalization:
Since `msb >= 64` is false (60 < 64):
```
r = sqrt_price_x64 << (63 - msb)
r = 2^60 << (63 - 60)
r = 2^60 << 3
r = 2^(60+3) = 2^63
```

In Q64.64 format:
- 2^63 represents the value 0.5 * 2^1 = 1.0
- The small value 0.0625 is normalized to 1.0, which is in the range [1,2)

## Visual Representation

Here's what's happening in binary for Example 3:

Original value (0.0625 in Q64.64):
```
0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
   ^                                                                            
   bit 60                                                                       
```

After shifting left by 3 bits:
```
0000 0000 0000 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
            ^                                                                   
            bit 63 (represents 1.0 in Q64.64)                                  
```

## Why This Normalization Works

The normalization ensures that:

1. **For any input value**, the result `r` will have its most significant bit at position 63
2. **In Q64.64 format**, a value with its MSB at position 63 represents a number in the range [1,2)
3. **This range [1,2)** is exactly what the binary logarithm algorithm requires to work correctly

By normalizing the input to this range, we can apply the iterative squaring algorithm consistently, regardless of the original input's magnitude.

The shifting operation effectively:
- Divides large numbers by powers of 2 (right shift)
- Multiplies small numbers by powers of 2 (left shift)

This is equivalent to finding the "scientific notation" of the number in base 2, then adjusting it so the mantissa is in [1,2

).


3. Normalization的解释 [TODO: 核心点]
The normalization technique works because of how binary numbers and the most significant bit (msb) relate to the value range.

Here's why this approach converts the value to the range [0.5,1):

1. Understanding the msb:
   - The msb tells us the position of the highest '1' bit in the number
   - If a number has its msb at position n, its value is between 2^n and 2^(n+1) 【TODO: 核心点】

2. For large values (msb ≥ 64):
   - The code shifts right by (msb - 63) bits: `sqrt_price_x64 >> (msb - 63)` 
   - This is equivalent to dividing by 2^(msb-63)
   - Since the original value is between 2^msb and 2^(msb+1), after division it becomes:
     - Between 2^msb ÷ 2^(msb-63) and 2^(msb+1) ÷ 2^(msb-63)
     - Which simplifies to between 2^63 and 2^64
   - In a Q64.64 format, this represents a value between 0.5 and 1
   - But the code uses msb-63 (not msb-64), which makes the range [0.5,1)

3. For small values (msb < 64):
   - The code shifts left by (63 - msb) bits: `sqrt_price_x64 << (63 - msb)`
   - This is equivalent to multiplying by 2^(63-msb)
   - This brings the value up to have its msb at position 63
   - This again places the value in the range [0.5,1)

The key insight is that by shifting based on the msb position, we're essentially "moving the decimal point" to get the value into the desired range, which is a fundamental step for the binary logarithm algorithm that follows.




更新版：
如何将r规范化到区间[1,2) ? 
### 结论
是的，这段代码把 `r` 规范化到了区间 [1, 2)（在 Q1.63 解释下）。

### 为什么
设 `v = sqrt_price_x64 > 0`，`msb = ⌊log2 v⌋`，则有
- 2^msb ≤ v < 2^(msb+1)

代码等价于把最高位移到第 63 位：
- 当 msb ≥ 64：r = v · 2^(63 − msb)
- 当 msb < 64： r = v · 2^(63 − msb)（左移同样是乘 2 的幂）

因此：
- 2^msb · 2^(63 − msb) ≤ r < 2^(msb+1) · 2^(63 − msb)
- 即 2^63 ≤ r < 2^64

把 `r` 按 Q1.63 解读为数值 r / 2^63，则
- 1 ≤ r/2^63 < 2
- 所以 `r ∈ [1, 2)`（上界 2 不取）

这正是把尾数规格化到 [1, 2) 的效果，方便后续平方得到 Q2.126 并做位测试与再归一化。

- 前提：`sqrt_price_x64` 非 0；若为 0，`msb` 无意义，算法不适用（在相关场景中不会出现）。 

- 小结
  - 通过把 `msb` 对齐到第 63 位，保证整数 r 落在 [2^63, 2^64)。
  - 在 Q1.63 的缩放下，即数值区间 [1, 2)。


  

  实例： price = 1.5   sqrt_price_x64 = 15061703465432641536 
 ./target/release/client create-po
ol 3 1.5 EUiTMqX7UxNpSsgUVFYKf9AFQb13MaJFpGMmwFor8kCx So111111111111111111111111111111111111
11112

代码：
    //case2: if msb < 64  =>  sqrt_price_x64 [1,2)
    let mut r = if msb >= 64 {
        sqrt_price_x64 >> (msb - 63)
    } else {
        sqrt_price_x64 << (63 - msb)
    };

    println!("r original value: {}", r);

r value = 15061703465432641536
>>> 15061703465432641536/2**63
1.632993161855452

sqrt_price_x64 = 22592555198148960256

step1: 
r*r: 127605887595351901203999652633466896384
>>> 127605887595351901203999652633466896384/2**126
1.4999999999999998

is_r_more_than_two: 0
r: 13835058055282161262
>>> 13835058055282161262/2**63
1.4999999999999998

log2p_fraction_x64: 0
bit: 4611686018427387904
**************precision***************: 1


r*r: 191408831393027817906363745797773432644
>>> 191408831393027817906363745797773432644/2**126
2.249999999999999

is_r_more_than_two: 1

r: 10376293541461619109
>>> 10376293541461619109/2**63
1.1249999999999996

log2p_fraction_x64: 4611686018427387904
bit: 2305843009213693952
**************precision***************: 2



r*r: 107667467658578109439450842139793953881
>>> 107667467658578109439450842139793953881/2**126
1.2656249999999991

is_r_more_than_two: 0
r: 11673330234144317363
>>> 11673330234144317363/2**63
1.2656249999999991

log2p_fraction_x64: 4611686018427387904
bit: 1152921504606846976
**************precision***************: 3


r*r: 136266638755387823229618933385263273769
>>> 136266638755387823229618933385263273769/2**126
1.6018066406249978

is_r_more_than_two: 0
r: 14774058577588891197
>>> 14774058577588891197/2**63
1.6018066406249978

log2p_fraction_x64: 4611686018427387904
bit: 576460752303423488
**************precision***************: 4


r*r: 218272806854027891009262086179904092809
>>> 218272806854027891009262086179904092809/2**126
2.565784513950341

is_r_more_than_two: 1
r: 11832592569282297096
>>> 11832592569282297096/2**63
1.2828922569751704

log2p_fraction_x64: 5188146770730811392
bit: 288230376151711744
**************precision***************: 5


r*r: 140010246910634632801839450898410033216
is_r_more_than_two: 0
r: 15179941387074195446
log2p_fraction_x64: 5188146770730811392
bit: 144115188075855872
**************precision***************: 6

r*r: 230430620515008048811930152168207138916
is_r_more_than_two: 1
r: 12491668968477728655
log2p_fraction_x64: 5332261958806667264
bit: 72057594037927936
**************precision***************: 7
r*r: 156041793618029441453803980747808109025
is_r_more_than_two: 0
r: 16918085163920224147
log2p_fraction_x64: 5332261958806667264
bit: 36028797018963968
**************precision***************: 8
r*r: 286221605613657597545836874402721877609
is_r_more_than_two: 1
r: 15516104330930840937
log2p_fraction_x64: 5368290755825631232
bit: 18014398509481984
**************precision***************: 9
r*r: 240749493608330799087120379269995037969
is_r_more_than_two: 1
r: 13051056199746865814
log2p_fraction_x64: 5386305154335113216
bit: 9007199254740992
**************precision***************: 10
r*r: 170330067928951103024809570516121882596
is_r_more_than_two: 1
r: 9233611484408616540
log2p_fraction_x64: 5395312353589854208
bit: 4503599627370496
**************precision***************: 11
r*r: 85259581045002695008759658196761571600
is_r_more_than_two: 0
r: 9243862299419585631
log2p_fraction_x64: 5395312353589854208
bit: 2251799813685248
**************precision***************: 12
r*r: 85448990210630748992382103439741668161
is_r_more_than_two: 0
r: 9264398082305845917
log2p_fraction_x64: 5395312353589854208
bit: 1125899906842624
**************precision***************: 13
r*r: 85829071827432235377778204112945570889
is_r_more_than_two: 0
r: 9305606613771643371
log2p_fraction_x64: 5395312353589854208
bit: 562949953421312
**************precision***************: 14
r*r: 86594314450270551081705858338008243641
is_r_more_than_two: 0
r: 9388574385187624109
log2p_fraction_x64: 5395312353589854208
bit: 281474976710656
**************precision***************: 15

r*r: 88145328986201174032566898736278043881
>>> 88145328986201174032566898736278043881/2**126
1.036143362746515

is_r_more_than_two: 0
r: 9556735718128881897
>>> 9556735718128881897/2**63
1.036143362746515

log2p_fraction_x64: 5395312353589854208
bit: 140737488355328
**************precision***************: 16


let log2p_fraction_x32 = log2p_fraction_x64 >> 32;
let log2p_x32 = log2p_integer_x32 + log2p_fraction_x32;

log2p_integer_x32: 0
log2p_fraction_x32: 1256194048
log2p_x32: 1256194048
log_sqrt_10001_x64: 74798650605840738811904