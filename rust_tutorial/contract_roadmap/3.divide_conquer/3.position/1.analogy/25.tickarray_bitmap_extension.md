目标：
1. what tickarray_bitmap_extension is ? 
2. what's the role of tickarray_bitmap in opening a position? 


内容：
1. 定义
 A per-pool PDA account that extends the default tick-array bitmap coverage. It stores two bitmaps (positive/negative) of initialized tick arrays, chunked into 14 “extension” windows. Each bit marks whether a tick array (identified by its start index) has been initialized.

结构体
#[account(zero_copy(unsafe))]
#[repr(C, packed)]
#[derive(Debug)]
pub struct TickArrayBitmapExtension {
    pub pool_id: Pubkey,
    pub positive_tick_array_bitmap: [[u64; 8]; EXTENSION_TICKARRAY_BITMAP_SIZE],
    pub negative_tick_array_bitmap: [[u64; 8]; EXTENSION_TICKARRAY_BITMAP_SIZE],
}

2. Role 
Role when opening a position: If the position’s lower/upper tick arrays fall outside the default bitmap coverage, the program requires passing this extension account so it can mark/consult those arrays. The check in open position:


let use_tickarray_bitmap_extension = pool_state.is_overflow_default_tickarray_bitmap(vec![
    tick_array_lower_start_index,
    tick_array_upper_start_index,
]);

If true, the instruction expects remaining_accounts[0] to be the extension PDA and validates the key:

if use_tickarray_bitmap_extension {
    require_keys_eq!(
        remaining_accounts[0].key(),
        TickArrayBitmapExtension::key(pool_state_loader.key())
    );
    Some(&remaining_accounts[0])
} else {
    None
}


This ensures the program can manage initialized-bit flags for tick arrays beyond the default bitmap window, allowing the position to be opened at far-away ranges while keeping constant-time checks for whether a tick array exists/initialized.


3. default value of tickarraybitmap_extension?

tickarray_bitmap_extension:TickArrayBitmapExtension { 
    pool_id: 8kgPAKAc1UdaRmytFfacJXxD8PUvRxFm7dgk7NeSyEK9, 
    positive_tick_array_bitmap: [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], 
    negative_tick_array_bitmap: [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]] 
    }

3.1 Its role in helping find the current and next five tick arrays ? 

 let mut tick_arrays = load_cur_and_next_five_tick_array(
                &rpc_client,
                &pool_config,
                &pool_state,
                &tickarray_bitmap_extension,
                zero_for_one,
            );

3.1.1 get_first_initialized_tick_array?


3.1.2 get_next_initialized_tick_array_start_index

3.1.3 check_current_tick_array_is_initialized
/// Given a tick, calculate whether the tickarray it belongs to has been initialized.
/// Note: The caller of the function should ensure that tick_current is within the range represented by bit_map.
/// Currently, this function is only called when `bit_map = pool.tick_array_bitmap`.